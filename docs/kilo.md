## Disclamair
**As always I'll write this here. My editor doesn't support emojis. I just like them, advent of AI has made it so that it's frowned upon FUCK AI FOR THAT. You'll see stuff like :some_emote: throughout the repo, I like it makes me laugh when I revisit my code.**
The resource files are generated by AI, so are the neovim architecture docs. Most of the others are hand written, with a heavy dose of stupidity, emotes and some very very poor jokes. 

I've not implemented the whole thing. This was just for exploration purpose to check in raw mode, how some of the UI rendering would be handled and the like.
I added a half baked vim type interface, with normal and insert mode. My version doesn't save back to a file.
If you want to write your own editor then this series is a really good starting ponit. You'll however want to look into more efficient buffer handling algorithms. Shifting the whole line whenever you type a character and rendering the whole screen again and again aren't really good for performance.


## Raw Mode
From [Ratatui](https://ratatui.rs/concepts/backends/raw-mode/): *Raw mode is a mode where the terminal does not perform any processing or handling of the input and output. This means that features such as echoing input characters, line buffering, and special character processing (e.g., CTRL-C or SIGINT) are disabled. This is useful for applications that want to have complete control over the terminal input and output, processing each keystroke themselves.*
So the above sums up raw mode. I'm not a particulary proficient writer, heh. (:sweat_smile:)

Yup so first thing we'd want for our TUI editor is raw mode. It simply means we as the develepor of the program are responsible for handling the relevant input signals that are norma to the OS.
Some of the most common ones are `Ctrl + C` which is the interrupt signal. It normally results in termination of the program. For a text editor or for a TUI you'd want it to copy the selectio to the clipboard. So you gotta disable it.
While I've listed only one there are tons and tons of them, [Signals](https://faculty.cs.niu.edu/~hutchins/csci480/signals.htm). You'll want to disabled all of them and just handle the ones you want yourself.

To do that you enter raw mode. In raw mode all the signals are just encoded as their constituent bytes and are streamed via the STDIN from where you can read those and call your corresponding handlers.

For instance in the blog for kilo, we use `Ctrl + Q` to quit. In essence all of the shortcuts, actions you want to perform are on some key combination, in raw mode you keep track of the keypresses (I didn't do it in this one but if you want something fully fledged you'll have to do it, I think :melting_face:)

Closing statements
- If you're gonna use raw mode, make sure your program has some kind of exit sequence. Otherwise once it's started the only way for the user to kill it is via external means which is not something you'd want to do.
- Think hard on which signals you want to ignore and which ones you want to keep. Write up functions for them at the very beginning. Helps avoiding conflicting key combos down the line.
- **Make sure to reset the terminal flags before program exits**. If you don't your configuration will be considered even after the program is done executing, and no user want's to operate their terminal in raw mode, unless they are masochistic, or mad. :laughing_face:. 

## Escape Sequences
So, escape the key when convertd to ASCII is **27** and in bytes `\x1b`. A lot of terminal operations like clearing the screen, moving the cursor etc, work via providing an escape sequence to the STDOUT stream.
Most of the terminal emulators support **[VT100](https://vt100.net/docs/vt100-ug/chapter3.html)** flavour of sequences.

What are escape sequences you ask, they're just a sequece of bytes that start with the escape key i.e. the byte representation would start with `\x1b`.
For exaple for moving the cursor to a given (row,col) you'd use: `\x1b[row;colH`, first. Intersting isn't it?
Similarly thre are sequencs to clear the whole screen, clear line, and other things. 

## State Management
Ohh, boy if this is not harder than it looks. There are a ton of things that you'd have to consider. Listing some among them:
- Current terminal size in rows, and cols. If window resizes, we'll have to adapt.
- If you're going for some kind of mode like me. Then which mode the user is in.
- Current buffer state.
- If the opened file has been modified or not.
- Syntax highlighting if you provide any.
- Notifications, draw redraw.
- If some part of the screen has become stale or irrelevant.

For screen redrawing you'll have to consider if the position of the curor is outsde of the currently rendered area and re-render. Otherwise just move it.
For a TUI some of the considerations might be voided, but some others might bery likely be added.

## References
[Kilo](https://viewsourcecode.org/snaptoken/kilo/index.html)
[VT100](https://vt100.net/docs/vt100-ug/chapter3.html)
